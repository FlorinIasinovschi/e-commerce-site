{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar parse = require('postcss-value-parser');\n\nvar parse__default = _interopDefault(parse);\n\nvar camelizeStyleName = _interopDefault(require('camelize'));\n\nvar cssColorKeywords = _interopDefault(require('css-color-keywords'));\n\nvar matchString = function matchString(node) {\n  if (node.type !== 'string') return null;\n  return node.value.replace(/\\\\([0-9a-f]{1,6})(?:\\s|$)/gi, function (match, charCode) {\n    return String.fromCharCode(parseInt(charCode, 16));\n  }).replace(/\\\\/g, '');\n};\n\nvar hexColorRe = /^(#(?:[0-9a-f]{3,4}){1,2})$/i;\nvar cssFunctionNameRe = /^(rgba?|hsla?|hwb|lab|lch|gray|color)$/;\n\nvar matchColor = function matchColor(node) {\n  if (node.type === 'word' && (hexColorRe.test(node.value) || node.value in cssColorKeywords || node.value === 'transparent')) {\n    return node.value;\n  } else if (node.type === 'function' && cssFunctionNameRe.test(node.value)) {\n    return parse.stringify(node);\n  }\n\n  return null;\n};\n\nvar noneRe = /^(none)$/i;\nvar autoRe = /^(auto)$/i;\nvar identRe = /(^-?[_a-z][_a-z0-9-]*$)/i; // Note if these are wrong, you'll need to change index.js too\n\nvar numberRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?)$/i; // Note lengthRe is sneaky: you can omit units for 0\n\nvar lengthRe = /^(0$|(?:[+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?)(?=px$))/i;\nvar unsupportedUnitRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?(ch|em|ex|rem|vh|vw|vmin|vmax|cm|mm|in|pc|pt))$/i;\nvar angleRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?(?:deg|rad))$/i;\nvar percentRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?%)$/i;\n\nvar noopToken = function noopToken(predicate) {\n  return function (node) {\n    return predicate(node) ? '<token>' : null;\n  };\n};\n\nvar valueForTypeToken = function valueForTypeToken(type) {\n  return function (node) {\n    return node.type === type ? node.value : null;\n  };\n};\n\nvar regExpToken = function regExpToken(regExp, transform) {\n  if (transform === void 0) {\n    transform = String;\n  }\n\n  return function (node) {\n    if (node.type !== 'word') return null;\n    var match = node.value.match(regExp);\n    if (match === null) return null;\n    var value = transform(match[1]);\n    return value;\n  };\n};\n\nvar SPACE = noopToken(function (node) {\n  return node.type === 'space';\n});\nvar SLASH = noopToken(function (node) {\n  return node.type === 'div' && node.value === '/';\n});\nvar COMMA = noopToken(function (node) {\n  return node.type === 'div' && node.value === ',';\n});\nvar WORD = valueForTypeToken('word');\nvar NONE = regExpToken(noneRe);\nvar AUTO = regExpToken(autoRe);\nvar NUMBER = regExpToken(numberRe, Number);\nvar LENGTH = regExpToken(lengthRe, Number);\nvar UNSUPPORTED_LENGTH_UNIT = regExpToken(unsupportedUnitRe);\nvar ANGLE = regExpToken(angleRe, function (angle) {\n  return angle.toLowerCase();\n});\nvar PERCENT = regExpToken(percentRe);\nvar IDENT = regExpToken(identRe);\nvar STRING = matchString;\nvar COLOR = matchColor;\nvar LINE = regExpToken(/^(none|underline|line-through)$/i);\nvar BORDER_STYLE = regExpToken(/^(solid|dashed|dotted)$/);\nvar defaultBorderWidth = 1;\nvar defaultBorderColor = 'black';\nvar defaultBorderStyle = 'solid';\n\nvar border = function border(tokenStream) {\n  var borderWidth;\n  var borderColor;\n  var borderStyle;\n\n  if (tokenStream.matches(NONE)) {\n    tokenStream.expectEmpty();\n    return {\n      borderWidth: 0,\n      borderColor: 'black',\n      borderStyle: 'solid'\n    };\n  }\n\n  var partsParsed = 0;\n\n  while (partsParsed < 3 && tokenStream.hasTokens()) {\n    if (partsParsed !== 0) tokenStream.expect(SPACE);\n\n    if (borderWidth === undefined && tokenStream.matches(LENGTH, UNSUPPORTED_LENGTH_UNIT)) {\n      borderWidth = tokenStream.lastValue;\n    } else if (borderColor === undefined && tokenStream.matches(COLOR)) {\n      borderColor = tokenStream.lastValue;\n    } else if (borderStyle === undefined && tokenStream.matches(BORDER_STYLE)) {\n      borderStyle = tokenStream.lastValue;\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    partsParsed += 1;\n  }\n\n  tokenStream.expectEmpty();\n  if (borderWidth === undefined) borderWidth = defaultBorderWidth;\n  if (borderColor === undefined) borderColor = defaultBorderColor;\n  if (borderStyle === undefined) borderStyle = defaultBorderStyle;\n  return {\n    borderWidth: borderWidth,\n    borderColor: borderColor,\n    borderStyle: borderStyle\n  };\n};\n\nvar directionFactory = function directionFactory(_ref) {\n  var _ref$types = _ref.types,\n      types = _ref$types === void 0 ? [LENGTH, UNSUPPORTED_LENGTH_UNIT, PERCENT] : _ref$types,\n      _ref$directions = _ref.directions,\n      directions = _ref$directions === void 0 ? ['Top', 'Right', 'Bottom', 'Left'] : _ref$directions,\n      _ref$prefix = _ref.prefix,\n      prefix = _ref$prefix === void 0 ? '' : _ref$prefix,\n      _ref$suffix = _ref.suffix,\n      suffix = _ref$suffix === void 0 ? '' : _ref$suffix;\n  return function (tokenStream) {\n    var _ref2;\n\n    var values = []; // borderWidth doesn't currently allow a percent value, but may do in the future\n\n    values.push(tokenStream.expect.apply(tokenStream, types));\n\n    while (values.length < 4 && tokenStream.hasTokens()) {\n      tokenStream.expect(SPACE);\n      values.push(tokenStream.expect.apply(tokenStream, types));\n    }\n\n    tokenStream.expectEmpty();\n    var top = values[0],\n        _values$ = values[1],\n        right = _values$ === void 0 ? top : _values$,\n        _values$2 = values[2],\n        bottom = _values$2 === void 0 ? top : _values$2,\n        _values$3 = values[3],\n        left = _values$3 === void 0 ? right : _values$3;\n\n    var keyFor = function keyFor(n) {\n      return \"\" + prefix + directions[n] + suffix;\n    };\n\n    return _ref2 = {}, _ref2[keyFor(0)] = top, _ref2[keyFor(1)] = right, _ref2[keyFor(2)] = bottom, _ref2[keyFor(3)] = left, _ref2;\n  };\n};\n\nvar parseShadowOffset = function parseShadowOffset(tokenStream) {\n  var width = tokenStream.expect(LENGTH);\n  var height = tokenStream.matches(SPACE) ? tokenStream.expect(LENGTH) : width;\n  tokenStream.expectEmpty();\n  return {\n    width: width,\n    height: height\n  };\n};\n\nvar parseShadow = function parseShadow(tokenStream) {\n  var offsetX;\n  var offsetY;\n  var radius;\n  var color;\n\n  if (tokenStream.matches(NONE)) {\n    tokenStream.expectEmpty();\n    return {\n      offset: {\n        width: 0,\n        height: 0\n      },\n      radius: 0,\n      color: 'black'\n    };\n  }\n\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE);\n\n    if (offsetX === undefined && tokenStream.matches(LENGTH, UNSUPPORTED_LENGTH_UNIT)) {\n      offsetX = tokenStream.lastValue;\n      tokenStream.expect(SPACE);\n      offsetY = tokenStream.expect(LENGTH, UNSUPPORTED_LENGTH_UNIT);\n      tokenStream.saveRewindPoint();\n\n      if (tokenStream.matches(SPACE) && tokenStream.matches(LENGTH, UNSUPPORTED_LENGTH_UNIT)) {\n        radius = tokenStream.lastValue;\n      } else {\n        tokenStream.rewind();\n      }\n    } else if (color === undefined && tokenStream.matches(COLOR)) {\n      color = tokenStream.lastValue;\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    didParseFirst = true;\n  }\n\n  if (offsetX === undefined) tokenStream[\"throw\"]();\n  return {\n    offset: {\n      width: offsetX,\n      height: offsetY\n    },\n    radius: radius !== undefined ? radius : 0,\n    color: color !== undefined ? color : 'black'\n  };\n};\n\nvar boxShadow = function boxShadow(tokenStream) {\n  var _parseShadow = parseShadow(tokenStream),\n      offset = _parseShadow.offset,\n      radius = _parseShadow.radius,\n      color = _parseShadow.color;\n\n  return {\n    shadowOffset: offset,\n    shadowRadius: radius,\n    shadowColor: color,\n    shadowOpacity: 1\n  };\n};\n\nvar defaultFlexGrow = 1;\nvar defaultFlexShrink = 1;\nvar defaultFlexBasis = 0;\n\nvar flex = function flex(tokenStream) {\n  var flexGrow;\n  var flexShrink;\n  var flexBasis;\n\n  if (tokenStream.matches(NONE)) {\n    tokenStream.expectEmpty();\n    return {\n      flexGrow: 0,\n      flexShrink: 0,\n      flexBasis: 'auto'\n    };\n  }\n\n  tokenStream.saveRewindPoint();\n\n  if (tokenStream.matches(AUTO) && !tokenStream.hasTokens()) {\n    return {\n      flexGrow: 1,\n      flexShrink: 1,\n      flexBasis: 'auto'\n    };\n  }\n\n  tokenStream.rewind();\n  var partsParsed = 0;\n\n  while (partsParsed < 2 && tokenStream.hasTokens()) {\n    if (partsParsed !== 0) tokenStream.expect(SPACE);\n\n    if (flexGrow === undefined && tokenStream.matches(NUMBER)) {\n      flexGrow = tokenStream.lastValue;\n      tokenStream.saveRewindPoint();\n\n      if (tokenStream.matches(SPACE) && tokenStream.matches(NUMBER)) {\n        flexShrink = tokenStream.lastValue;\n      } else {\n        tokenStream.rewind();\n      }\n    } else if (flexBasis === undefined && tokenStream.matches(LENGTH, UNSUPPORTED_LENGTH_UNIT, PERCENT)) {\n      flexBasis = tokenStream.lastValue;\n    } else if (flexBasis === undefined && tokenStream.matches(AUTO)) {\n      flexBasis = 'auto';\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    partsParsed += 1;\n  }\n\n  tokenStream.expectEmpty();\n  if (flexGrow === undefined) flexGrow = defaultFlexGrow;\n  if (flexShrink === undefined) flexShrink = defaultFlexShrink;\n  if (flexBasis === undefined) flexBasis = defaultFlexBasis;\n  return {\n    flexGrow: flexGrow,\n    flexShrink: flexShrink,\n    flexBasis: flexBasis\n  };\n};\n\nvar FLEX_WRAP = regExpToken(/(nowrap|wrap|wrap-reverse)/);\nvar FLEX_DIRECTION = regExpToken(/(row|row-reverse|column|column-reverse)/);\nvar defaultFlexWrap = 'nowrap';\nvar defaultFlexDirection = 'row';\n\nvar flexFlow = function flexFlow(tokenStream) {\n  var flexWrap;\n  var flexDirection;\n  var partsParsed = 0;\n\n  while (partsParsed < 2 && tokenStream.hasTokens()) {\n    if (partsParsed !== 0) tokenStream.expect(SPACE);\n\n    if (flexWrap === undefined && tokenStream.matches(FLEX_WRAP)) {\n      flexWrap = tokenStream.lastValue;\n    } else if (flexDirection === undefined && tokenStream.matches(FLEX_DIRECTION)) {\n      flexDirection = tokenStream.lastValue;\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    partsParsed += 1;\n  }\n\n  tokenStream.expectEmpty();\n  if (flexWrap === undefined) flexWrap = defaultFlexWrap;\n  if (flexDirection === undefined) flexDirection = defaultFlexDirection;\n  return {\n    flexWrap: flexWrap,\n    flexDirection: flexDirection\n  };\n};\n\nvar fontFamily = function fontFamily(tokenStream) {\n  var fontFamily;\n\n  if (tokenStream.matches(STRING)) {\n    fontFamily = tokenStream.lastValue;\n  } else {\n    fontFamily = tokenStream.expect(IDENT);\n\n    while (tokenStream.hasTokens()) {\n      tokenStream.expect(SPACE);\n      var nextIdent = tokenStream.expect(IDENT);\n      fontFamily += \" \" + nextIdent;\n    }\n  }\n\n  tokenStream.expectEmpty();\n  return {\n    fontFamily: fontFamily\n  };\n};\n\nvar NORMAL = regExpToken(/^(normal)$/);\nvar STYLE = regExpToken(/^(italic)$/);\nvar WEIGHT = regExpToken(/^([1-9]00|bold)$/);\nvar VARIANT = regExpToken(/^(small-caps)$/);\nvar defaultFontStyle = 'normal';\nvar defaultFontWeight = 'normal';\nvar defaultFontVariant = [];\n\nvar font = function font(tokenStream) {\n  var fontStyle;\n  var fontWeight;\n  var fontVariant; // let fontSize;\n\n  var lineHeight; // let fontFamily;\n\n  var numStyleWeightVariantMatched = 0;\n\n  while (numStyleWeightVariantMatched < 3 && tokenStream.hasTokens()) {\n    if (tokenStream.matches(NORMAL)) ;else if (fontStyle === undefined && tokenStream.matches(STYLE)) {\n      fontStyle = tokenStream.lastValue;\n    } else if (fontWeight === undefined && tokenStream.matches(WEIGHT)) {\n      fontWeight = tokenStream.lastValue;\n    } else if (fontVariant === undefined && tokenStream.matches(VARIANT)) {\n      fontVariant = [tokenStream.lastValue];\n    } else {\n      break;\n    }\n    tokenStream.expect(SPACE);\n    numStyleWeightVariantMatched += 1;\n  }\n\n  var fontSize = tokenStream.expect(LENGTH, UNSUPPORTED_LENGTH_UNIT);\n\n  if (tokenStream.matches(SLASH)) {\n    lineHeight = tokenStream.expect(LENGTH, UNSUPPORTED_LENGTH_UNIT);\n  }\n\n  tokenStream.expect(SPACE);\n\n  var _fontFamily = fontFamily(tokenStream),\n      fontFamily$1 = _fontFamily.fontFamily;\n\n  if (fontStyle === undefined) fontStyle = defaultFontStyle;\n  if (fontWeight === undefined) fontWeight = defaultFontWeight;\n  if (fontVariant === undefined) fontVariant = defaultFontVariant;\n  var out = {\n    fontStyle: fontStyle,\n    fontWeight: fontWeight,\n    fontVariant: fontVariant,\n    fontSize: fontSize,\n    fontFamily: fontFamily$1\n  };\n  if (lineHeight !== undefined) out.lineHeight = lineHeight;\n  return out;\n};\n\nvar ALIGN_CONTENT = regExpToken(/(flex-(?:start|end)|center|stretch|space-(?:between|around))/);\nvar JUSTIFY_CONTENT = regExpToken(/(flex-(?:start|end)|center|space-(?:between|around|evenly))/);\n\nvar placeContent = function placeContent(tokenStream) {\n  var alignContent = tokenStream.expect(ALIGN_CONTENT);\n  var justifyContent;\n\n  if (tokenStream.hasTokens()) {\n    tokenStream.expect(SPACE);\n    justifyContent = tokenStream.expect(JUSTIFY_CONTENT);\n  } else {\n    justifyContent = 'stretch';\n  }\n\n  tokenStream.expectEmpty();\n  return {\n    alignContent: alignContent,\n    justifyContent: justifyContent\n  };\n};\n\nvar STYLE$1 = regExpToken(/^(solid|double|dotted|dashed)$/);\nvar defaultTextDecorationLine = 'none';\nvar defaultTextDecorationStyle = 'solid';\nvar defaultTextDecorationColor = 'black';\n\nvar textDecoration = function textDecoration(tokenStream) {\n  var line;\n  var style;\n  var color;\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE);\n\n    if (line === undefined && tokenStream.matches(LINE)) {\n      var lines = [tokenStream.lastValue.toLowerCase()];\n      tokenStream.saveRewindPoint();\n\n      if (lines[0] !== 'none' && tokenStream.matches(SPACE) && tokenStream.matches(LINE)) {\n        lines.push(tokenStream.lastValue.toLowerCase()); // Underline comes before line-through\n\n        lines.sort().reverse();\n      } else {\n        tokenStream.rewind();\n      }\n\n      line = lines.join(' ');\n    } else if (style === undefined && tokenStream.matches(STYLE$1)) {\n      style = tokenStream.lastValue;\n    } else if (color === undefined && tokenStream.matches(COLOR)) {\n      color = tokenStream.lastValue;\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    didParseFirst = true;\n  }\n\n  return {\n    textDecorationLine: line !== undefined ? line : defaultTextDecorationLine,\n    textDecorationColor: color !== undefined ? color : defaultTextDecorationColor,\n    textDecorationStyle: style !== undefined ? style : defaultTextDecorationStyle\n  };\n};\n\nvar textDecorationLine = function textDecorationLine(tokenStream) {\n  var lines = [];\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE);\n    lines.push(tokenStream.expect(LINE).toLowerCase());\n    didParseFirst = true;\n  }\n\n  lines.sort().reverse();\n  return {\n    textDecorationLine: lines.join(' ')\n  };\n};\n\nvar textShadow = function textShadow(tokenStream) {\n  var _parseShadow2 = parseShadow(tokenStream),\n      offset = _parseShadow2.offset,\n      radius = _parseShadow2.radius,\n      color = _parseShadow2.color;\n\n  return {\n    textShadowOffset: offset,\n    textShadowRadius: radius,\n    textShadowColor: color\n  };\n};\n\nvar oneOfType = function oneOfType(tokenType) {\n  return function (functionStream) {\n    var value = functionStream.expect(tokenType);\n    functionStream.expectEmpty();\n    return value;\n  };\n};\n\nvar singleNumber = oneOfType(NUMBER);\nvar singleLength = oneOfType(LENGTH);\nvar singleAngle = oneOfType(ANGLE);\n\nvar xyTransformFactory = function xyTransformFactory(tokenType) {\n  return function (key, valueIfOmitted) {\n    return function (functionStream) {\n      var _ref3, _ref4;\n\n      var x = functionStream.expect(tokenType);\n      var y;\n\n      if (functionStream.hasTokens()) {\n        functionStream.expect(COMMA);\n        y = functionStream.expect(tokenType);\n      } else if (valueIfOmitted !== undefined) {\n        y = valueIfOmitted;\n      } else {\n        // Assumption, if x === y, then we can omit XY\n        // I.e. scale(5) => [{ scale: 5 }] rather than [{ scaleX: 5 }, { scaleY: 5 }]\n        return x;\n      }\n\n      functionStream.expectEmpty();\n      return [(_ref3 = {}, _ref3[key + \"Y\"] = y, _ref3), (_ref4 = {}, _ref4[key + \"X\"] = x, _ref4)];\n    };\n  };\n};\n\nvar xyNumber = xyTransformFactory(NUMBER);\nvar xyLength = xyTransformFactory(LENGTH);\nvar xyAngle = xyTransformFactory(ANGLE);\nvar partTransforms = {\n  perspective: singleNumber,\n  scale: xyNumber('scale'),\n  scaleX: singleNumber,\n  scaleY: singleNumber,\n  translate: xyLength('translate', 0),\n  translateX: singleLength,\n  translateY: singleLength,\n  rotate: singleAngle,\n  rotateX: singleAngle,\n  rotateY: singleAngle,\n  rotateZ: singleAngle,\n  skewX: singleAngle,\n  skewY: singleAngle,\n  skew: xyAngle('skew', '0deg')\n};\n\nvar transform = function transform(tokenStream) {\n  var transforms = [];\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE);\n    var functionStream = tokenStream.expectFunction();\n    var functionName = functionStream.functionName;\n    var transformedValues = partTransforms[functionName](functionStream);\n\n    if (!Array.isArray(transformedValues)) {\n      var _ref5;\n\n      transformedValues = [(_ref5 = {}, _ref5[functionName] = transformedValues, _ref5)];\n    }\n\n    transforms = transformedValues.concat(transforms);\n    didParseFirst = true;\n  }\n\n  return {\n    transform: transforms\n  };\n};\n\nvar background = function background(tokenStream) {\n  return {\n    backgroundColor: tokenStream.expect(COLOR)\n  };\n};\n\nvar borderColor = directionFactory({\n  types: [COLOR],\n  prefix: 'border',\n  suffix: 'Color'\n});\nvar borderRadius = directionFactory({\n  directions: ['TopLeft', 'TopRight', 'BottomRight', 'BottomLeft'],\n  prefix: 'border',\n  suffix: 'Radius'\n});\nvar borderWidth = directionFactory({\n  prefix: 'border',\n  suffix: 'Width'\n});\nvar margin = directionFactory({\n  types: [LENGTH, UNSUPPORTED_LENGTH_UNIT, PERCENT, AUTO],\n  prefix: 'margin'\n});\nvar padding = directionFactory({\n  prefix: 'padding'\n});\n\nvar fontVariant = function fontVariant(tokenStream) {\n  return {\n    fontVariant: [tokenStream.expect(IDENT)]\n  };\n};\n\nvar fontWeight = function fontWeight(tokenStream) {\n  return {\n    fontWeight: tokenStream.expect(WORD) // Also match numbers as strings\n\n  };\n};\n\nvar shadowOffset = function shadowOffset(tokenStream) {\n  return {\n    shadowOffset: parseShadowOffset(tokenStream)\n  };\n};\n\nvar textShadowOffset = function textShadowOffset(tokenStream) {\n  return {\n    textShadowOffset: parseShadowOffset(tokenStream)\n  };\n};\n\nvar transforms = {\n  background: background,\n  border: border,\n  borderColor: borderColor,\n  borderRadius: borderRadius,\n  borderWidth: borderWidth,\n  boxShadow: boxShadow,\n  flex: flex,\n  flexFlow: flexFlow,\n  font: font,\n  fontFamily: fontFamily,\n  fontVariant: fontVariant,\n  fontWeight: fontWeight,\n  margin: margin,\n  padding: padding,\n  placeContent: placeContent,\n  shadowOffset: shadowOffset,\n  textShadow: textShadow,\n  textShadowOffset: textShadowOffset,\n  textDecoration: textDecoration,\n  textDecorationLine: textDecorationLine,\n  transform: transform\n};\nvar propertiesWithoutUnits;\n\nif (process.env.NODE_ENV !== 'production') {\n  propertiesWithoutUnits = ['aspectRatio', 'elevation', 'flexGrow', 'flexShrink', 'opacity', 'shadowOpacity', 'zIndex'];\n}\n\nvar devPropertiesWithUnitsRegExp = propertiesWithoutUnits != null ? new RegExp(propertiesWithoutUnits.join('|')) : null;\nvar SYMBOL_MATCH = 'SYMBOL_MATCH';\n\nvar TokenStream = /*#__PURE__*/function () {\n  function TokenStream(nodes, parent) {\n    this.index = 0;\n    this.nodes = nodes;\n    this.functionName = parent != null ? parent.value : null;\n    this.lastValue = null;\n    this.rewindIndex = -1;\n  }\n\n  var _proto = TokenStream.prototype;\n\n  _proto.hasTokens = function hasTokens() {\n    return this.index <= this.nodes.length - 1;\n  };\n\n  _proto[SYMBOL_MATCH] = function () {\n    if (!this.hasTokens()) return null;\n    var node = this.nodes[this.index];\n\n    for (var i = 0; i < arguments.length; i += 1) {\n      var tokenDescriptor = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      var value = tokenDescriptor(node);\n\n      if (value !== null) {\n        this.index += 1;\n        this.lastValue = value;\n        return value;\n      }\n    }\n\n    return null;\n  };\n\n  _proto.matches = function matches() {\n    return this[SYMBOL_MATCH].apply(this, arguments) !== null;\n  };\n\n  _proto.expect = function expect() {\n    var value = this[SYMBOL_MATCH].apply(this, arguments);\n    return value !== null ? value : this[\"throw\"]();\n  };\n\n  _proto.matchesFunction = function matchesFunction() {\n    var node = this.nodes[this.index];\n    if (node.type !== 'function') return null;\n    var value = new TokenStream(node.nodes, node);\n    this.index += 1;\n    this.lastValue = null;\n    return value;\n  };\n\n  _proto.expectFunction = function expectFunction() {\n    var value = this.matchesFunction();\n    return value !== null ? value : this[\"throw\"]();\n  };\n\n  _proto.expectEmpty = function expectEmpty() {\n    if (this.hasTokens()) this[\"throw\"]();\n  };\n\n  _proto[\"throw\"] = function _throw() {\n    throw new Error(\"Unexpected token type: \" + this.nodes[this.index].type);\n  };\n\n  _proto.saveRewindPoint = function saveRewindPoint() {\n    this.rewindIndex = this.index;\n  };\n\n  _proto.rewind = function rewind() {\n    if (this.rewindIndex === -1) throw new Error('Internal error');\n    this.index = this.rewindIndex;\n    this.lastValue = null;\n  };\n\n  return TokenStream;\n}();\n/* eslint-disable no-param-reassign */\n// Note if this is wrong, you'll need to change tokenTypes.js too\n\n\nvar numberOrLengthRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?)(?:px)?$/i;\nvar numberOnlyRe = /^[+-]?(?:\\d*\\.\\d*|[1-9]\\d*)(?:e[+-]?\\d+)?$/i;\nvar boolRe = /^true|false$/i;\nvar nullRe = /^null$/i;\nvar undefinedRe = /^undefined$/i; // Undocumented export\n\nvar transformRawValue = function transformRawValue(propName, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    var needsUnit = !devPropertiesWithUnitsRegExp.test(propName);\n    var isNumberWithoutUnit = numberOnlyRe.test(value);\n\n    if (needsUnit && isNumberWithoutUnit) {\n      // eslint-disable-next-line no-console\n      console.warn(\"Expected style \\\"\" + propName + \": \" + value + \"\\\" to contain units\");\n    }\n\n    if (!needsUnit && value !== '0' && !isNumberWithoutUnit) {\n      // eslint-disable-next-line no-console\n      console.warn(\"Expected style \\\"\" + propName + \": \" + value + \"\\\" to be unitless\");\n    }\n  }\n\n  var numberMatch = value.match(numberOrLengthRe);\n  if (numberMatch !== null) return Number(numberMatch[1]);\n  var boolMatch = value.match(boolRe);\n  if (boolMatch !== null) return boolMatch[0].toLowerCase() === 'true';\n  var nullMatch = value.match(nullRe);\n  if (nullMatch !== null) return null;\n  var undefinedMatch = value.match(undefinedRe);\n  if (undefinedMatch !== null) return undefined;\n  return value;\n};\n\nvar baseTransformShorthandValue = function baseTransformShorthandValue(propName, value) {\n  var ast = parse__default(value);\n  var tokenStream = new TokenStream(ast.nodes);\n  return transforms[propName](tokenStream);\n};\n\nvar transformShorthandValue = process.env.NODE_ENV === 'production' ? baseTransformShorthandValue : function (propName, value) {\n  try {\n    return baseTransformShorthandValue(propName, value);\n  } catch (e) {\n    throw new Error(\"Failed to parse declaration \\\"\" + propName + \": \" + value + \"\\\"\");\n  }\n};\n\nvar getStylesForProperty = function getStylesForProperty(propName, inputValue, allowShorthand) {\n  var _ref6;\n\n  var isRawValue = allowShorthand === false || !(propName in transforms);\n  var value = inputValue.trim();\n  var propValues = isRawValue ? (_ref6 = {}, _ref6[propName] = transformRawValue(propName, value), _ref6) : transformShorthandValue(propName, value);\n  return propValues;\n};\n\nvar getPropertyName = function getPropertyName(propName) {\n  var isCustomProp = /^--\\w+/.test(propName);\n\n  if (isCustomProp) {\n    return propName;\n  }\n\n  return camelizeStyleName(propName);\n};\n\nvar index = function index(rules, shorthandBlacklist) {\n  if (shorthandBlacklist === void 0) {\n    shorthandBlacklist = [];\n  }\n\n  return rules.reduce(function (accum, rule) {\n    var propertyName = getPropertyName(rule[0]);\n    var value = rule[1];\n    var allowShorthand = shorthandBlacklist.indexOf(propertyName) === -1;\n    return Object.assign(accum, getStylesForProperty(propertyName, value, allowShorthand));\n  }, {});\n};\n\nexports[\"default\"] = index;\nexports.getPropertyName = getPropertyName;\nexports.getStylesForProperty = getStylesForProperty;\nexports.transformRawValue = transformRawValue;","map":{"version":3,"sources":["G:/Dropbox (Personale)/Programming/ecommerce-site/node_modules/css-to-react-native/index.js"],"names":["Object","defineProperty","exports","value","_interopDefault","ex","parse","require","parse__default","camelizeStyleName","cssColorKeywords","matchString","node","type","replace","match","charCode","String","fromCharCode","parseInt","hexColorRe","cssFunctionNameRe","matchColor","test","stringify","noneRe","autoRe","identRe","numberRe","lengthRe","unsupportedUnitRe","angleRe","percentRe","noopToken","predicate","valueForTypeToken","regExpToken","regExp","transform","SPACE","SLASH","COMMA","WORD","NONE","AUTO","NUMBER","Number","LENGTH","UNSUPPORTED_LENGTH_UNIT","ANGLE","angle","toLowerCase","PERCENT","IDENT","STRING","COLOR","LINE","BORDER_STYLE","defaultBorderWidth","defaultBorderColor","defaultBorderStyle","border","tokenStream","borderWidth","borderColor","borderStyle","matches","expectEmpty","partsParsed","hasTokens","expect","undefined","lastValue","directionFactory","_ref","_ref$types","types","_ref$directions","directions","_ref$prefix","prefix","_ref$suffix","suffix","_ref2","values","push","apply","length","top","_values$","right","_values$2","bottom","_values$3","left","keyFor","n","parseShadowOffset","width","height","parseShadow","offsetX","offsetY","radius","color","offset","didParseFirst","saveRewindPoint","rewind","boxShadow","_parseShadow","shadowOffset","shadowRadius","shadowColor","shadowOpacity","defaultFlexGrow","defaultFlexShrink","defaultFlexBasis","flex","flexGrow","flexShrink","flexBasis","FLEX_WRAP","FLEX_DIRECTION","defaultFlexWrap","defaultFlexDirection","flexFlow","flexWrap","flexDirection","fontFamily","nextIdent","NORMAL","STYLE","WEIGHT","VARIANT","defaultFontStyle","defaultFontWeight","defaultFontVariant","font","fontStyle","fontWeight","fontVariant","lineHeight","numStyleWeightVariantMatched","fontSize","_fontFamily","fontFamily$1","out","ALIGN_CONTENT","JUSTIFY_CONTENT","placeContent","alignContent","justifyContent","STYLE$1","defaultTextDecorationLine","defaultTextDecorationStyle","defaultTextDecorationColor","textDecoration","line","style","lines","sort","reverse","join","textDecorationLine","textDecorationColor","textDecorationStyle","textShadow","_parseShadow2","textShadowOffset","textShadowRadius","textShadowColor","oneOfType","tokenType","functionStream","singleNumber","singleLength","singleAngle","xyTransformFactory","key","valueIfOmitted","_ref3","_ref4","x","y","xyNumber","xyLength","xyAngle","partTransforms","perspective","scale","scaleX","scaleY","translate","translateX","translateY","rotate","rotateX","rotateY","rotateZ","skewX","skewY","skew","transforms","expectFunction","functionName","transformedValues","Array","isArray","_ref5","concat","background","backgroundColor","borderRadius","margin","padding","propertiesWithoutUnits","process","env","NODE_ENV","devPropertiesWithUnitsRegExp","RegExp","SYMBOL_MATCH","TokenStream","nodes","parent","index","rewindIndex","_proto","prototype","i","arguments","tokenDescriptor","matchesFunction","_throw","Error","numberOrLengthRe","numberOnlyRe","boolRe","nullRe","undefinedRe","transformRawValue","propName","needsUnit","isNumberWithoutUnit","console","warn","numberMatch","boolMatch","nullMatch","undefinedMatch","baseTransformShorthandValue","ast","transformShorthandValue","e","getStylesForProperty","inputValue","allowShorthand","_ref6","isRawValue","trim","propValues","getPropertyName","isCustomProp","rules","shorthandBlacklist","reduce","accum","rule","propertyName","indexOf","assign"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar parse = require('postcss-value-parser');\n\nvar parse__default = _interopDefault(parse);\n\nvar camelizeStyleName = _interopDefault(require('camelize'));\n\nvar cssColorKeywords = _interopDefault(require('css-color-keywords'));\n\nvar matchString = function matchString(node) {\n  if (node.type !== 'string') return null;\n  return node.value.replace(/\\\\([0-9a-f]{1,6})(?:\\s|$)/gi, function (match, charCode) {\n    return String.fromCharCode(parseInt(charCode, 16));\n  }).replace(/\\\\/g, '');\n};\n\nvar hexColorRe = /^(#(?:[0-9a-f]{3,4}){1,2})$/i;\nvar cssFunctionNameRe = /^(rgba?|hsla?|hwb|lab|lch|gray|color)$/;\n\nvar matchColor = function matchColor(node) {\n  if (node.type === 'word' && (hexColorRe.test(node.value) || node.value in cssColorKeywords || node.value === 'transparent')) {\n    return node.value;\n  } else if (node.type === 'function' && cssFunctionNameRe.test(node.value)) {\n    return parse.stringify(node);\n  }\n\n  return null;\n};\n\nvar noneRe = /^(none)$/i;\nvar autoRe = /^(auto)$/i;\nvar identRe = /(^-?[_a-z][_a-z0-9-]*$)/i; // Note if these are wrong, you'll need to change index.js too\n\nvar numberRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?)$/i; // Note lengthRe is sneaky: you can omit units for 0\n\nvar lengthRe = /^(0$|(?:[+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?)(?=px$))/i;\nvar unsupportedUnitRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?(ch|em|ex|rem|vh|vw|vmin|vmax|cm|mm|in|pc|pt))$/i;\nvar angleRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?(?:deg|rad))$/i;\nvar percentRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?%)$/i;\n\nvar noopToken = function noopToken(predicate) {\n  return function (node) {\n    return predicate(node) ? '<token>' : null;\n  };\n};\n\nvar valueForTypeToken = function valueForTypeToken(type) {\n  return function (node) {\n    return node.type === type ? node.value : null;\n  };\n};\n\nvar regExpToken = function regExpToken(regExp, transform) {\n  if (transform === void 0) {\n    transform = String;\n  }\n\n  return function (node) {\n    if (node.type !== 'word') return null;\n    var match = node.value.match(regExp);\n    if (match === null) return null;\n    var value = transform(match[1]);\n    return value;\n  };\n};\n\nvar SPACE = noopToken(function (node) {\n  return node.type === 'space';\n});\nvar SLASH = noopToken(function (node) {\n  return node.type === 'div' && node.value === '/';\n});\nvar COMMA = noopToken(function (node) {\n  return node.type === 'div' && node.value === ',';\n});\nvar WORD = valueForTypeToken('word');\nvar NONE = regExpToken(noneRe);\nvar AUTO = regExpToken(autoRe);\nvar NUMBER = regExpToken(numberRe, Number);\nvar LENGTH = regExpToken(lengthRe, Number);\nvar UNSUPPORTED_LENGTH_UNIT = regExpToken(unsupportedUnitRe);\nvar ANGLE = regExpToken(angleRe, function (angle) {\n  return angle.toLowerCase();\n});\nvar PERCENT = regExpToken(percentRe);\nvar IDENT = regExpToken(identRe);\nvar STRING = matchString;\nvar COLOR = matchColor;\nvar LINE = regExpToken(/^(none|underline|line-through)$/i);\nvar BORDER_STYLE = regExpToken(/^(solid|dashed|dotted)$/);\nvar defaultBorderWidth = 1;\nvar defaultBorderColor = 'black';\nvar defaultBorderStyle = 'solid';\n\nvar border = function border(tokenStream) {\n  var borderWidth;\n  var borderColor;\n  var borderStyle;\n\n  if (tokenStream.matches(NONE)) {\n    tokenStream.expectEmpty();\n    return {\n      borderWidth: 0,\n      borderColor: 'black',\n      borderStyle: 'solid'\n    };\n  }\n\n  var partsParsed = 0;\n\n  while (partsParsed < 3 && tokenStream.hasTokens()) {\n    if (partsParsed !== 0) tokenStream.expect(SPACE);\n\n    if (borderWidth === undefined && tokenStream.matches(LENGTH, UNSUPPORTED_LENGTH_UNIT)) {\n      borderWidth = tokenStream.lastValue;\n    } else if (borderColor === undefined && tokenStream.matches(COLOR)) {\n      borderColor = tokenStream.lastValue;\n    } else if (borderStyle === undefined && tokenStream.matches(BORDER_STYLE)) {\n      borderStyle = tokenStream.lastValue;\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    partsParsed += 1;\n  }\n\n  tokenStream.expectEmpty();\n  if (borderWidth === undefined) borderWidth = defaultBorderWidth;\n  if (borderColor === undefined) borderColor = defaultBorderColor;\n  if (borderStyle === undefined) borderStyle = defaultBorderStyle;\n  return {\n    borderWidth: borderWidth,\n    borderColor: borderColor,\n    borderStyle: borderStyle\n  };\n};\n\nvar directionFactory = function directionFactory(_ref) {\n  var _ref$types = _ref.types,\n      types = _ref$types === void 0 ? [LENGTH, UNSUPPORTED_LENGTH_UNIT, PERCENT] : _ref$types,\n      _ref$directions = _ref.directions,\n      directions = _ref$directions === void 0 ? ['Top', 'Right', 'Bottom', 'Left'] : _ref$directions,\n      _ref$prefix = _ref.prefix,\n      prefix = _ref$prefix === void 0 ? '' : _ref$prefix,\n      _ref$suffix = _ref.suffix,\n      suffix = _ref$suffix === void 0 ? '' : _ref$suffix;\n  return function (tokenStream) {\n    var _ref2;\n\n    var values = []; // borderWidth doesn't currently allow a percent value, but may do in the future\n\n    values.push(tokenStream.expect.apply(tokenStream, types));\n\n    while (values.length < 4 && tokenStream.hasTokens()) {\n      tokenStream.expect(SPACE);\n      values.push(tokenStream.expect.apply(tokenStream, types));\n    }\n\n    tokenStream.expectEmpty();\n    var top = values[0],\n        _values$ = values[1],\n        right = _values$ === void 0 ? top : _values$,\n        _values$2 = values[2],\n        bottom = _values$2 === void 0 ? top : _values$2,\n        _values$3 = values[3],\n        left = _values$3 === void 0 ? right : _values$3;\n\n    var keyFor = function keyFor(n) {\n      return \"\" + prefix + directions[n] + suffix;\n    };\n\n    return _ref2 = {}, _ref2[keyFor(0)] = top, _ref2[keyFor(1)] = right, _ref2[keyFor(2)] = bottom, _ref2[keyFor(3)] = left, _ref2;\n  };\n};\n\nvar parseShadowOffset = function parseShadowOffset(tokenStream) {\n  var width = tokenStream.expect(LENGTH);\n  var height = tokenStream.matches(SPACE) ? tokenStream.expect(LENGTH) : width;\n  tokenStream.expectEmpty();\n  return {\n    width: width,\n    height: height\n  };\n};\n\nvar parseShadow = function parseShadow(tokenStream) {\n  var offsetX;\n  var offsetY;\n  var radius;\n  var color;\n\n  if (tokenStream.matches(NONE)) {\n    tokenStream.expectEmpty();\n    return {\n      offset: {\n        width: 0,\n        height: 0\n      },\n      radius: 0,\n      color: 'black'\n    };\n  }\n\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE);\n\n    if (offsetX === undefined && tokenStream.matches(LENGTH, UNSUPPORTED_LENGTH_UNIT)) {\n      offsetX = tokenStream.lastValue;\n      tokenStream.expect(SPACE);\n      offsetY = tokenStream.expect(LENGTH, UNSUPPORTED_LENGTH_UNIT);\n      tokenStream.saveRewindPoint();\n\n      if (tokenStream.matches(SPACE) && tokenStream.matches(LENGTH, UNSUPPORTED_LENGTH_UNIT)) {\n        radius = tokenStream.lastValue;\n      } else {\n        tokenStream.rewind();\n      }\n    } else if (color === undefined && tokenStream.matches(COLOR)) {\n      color = tokenStream.lastValue;\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    didParseFirst = true;\n  }\n\n  if (offsetX === undefined) tokenStream[\"throw\"]();\n  return {\n    offset: {\n      width: offsetX,\n      height: offsetY\n    },\n    radius: radius !== undefined ? radius : 0,\n    color: color !== undefined ? color : 'black'\n  };\n};\n\nvar boxShadow = function boxShadow(tokenStream) {\n  var _parseShadow = parseShadow(tokenStream),\n      offset = _parseShadow.offset,\n      radius = _parseShadow.radius,\n      color = _parseShadow.color;\n\n  return {\n    shadowOffset: offset,\n    shadowRadius: radius,\n    shadowColor: color,\n    shadowOpacity: 1\n  };\n};\n\nvar defaultFlexGrow = 1;\nvar defaultFlexShrink = 1;\nvar defaultFlexBasis = 0;\n\nvar flex = function flex(tokenStream) {\n  var flexGrow;\n  var flexShrink;\n  var flexBasis;\n\n  if (tokenStream.matches(NONE)) {\n    tokenStream.expectEmpty();\n    return {\n      flexGrow: 0,\n      flexShrink: 0,\n      flexBasis: 'auto'\n    };\n  }\n\n  tokenStream.saveRewindPoint();\n\n  if (tokenStream.matches(AUTO) && !tokenStream.hasTokens()) {\n    return {\n      flexGrow: 1,\n      flexShrink: 1,\n      flexBasis: 'auto'\n    };\n  }\n\n  tokenStream.rewind();\n  var partsParsed = 0;\n\n  while (partsParsed < 2 && tokenStream.hasTokens()) {\n    if (partsParsed !== 0) tokenStream.expect(SPACE);\n\n    if (flexGrow === undefined && tokenStream.matches(NUMBER)) {\n      flexGrow = tokenStream.lastValue;\n      tokenStream.saveRewindPoint();\n\n      if (tokenStream.matches(SPACE) && tokenStream.matches(NUMBER)) {\n        flexShrink = tokenStream.lastValue;\n      } else {\n        tokenStream.rewind();\n      }\n    } else if (flexBasis === undefined && tokenStream.matches(LENGTH, UNSUPPORTED_LENGTH_UNIT, PERCENT)) {\n      flexBasis = tokenStream.lastValue;\n    } else if (flexBasis === undefined && tokenStream.matches(AUTO)) {\n      flexBasis = 'auto';\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    partsParsed += 1;\n  }\n\n  tokenStream.expectEmpty();\n  if (flexGrow === undefined) flexGrow = defaultFlexGrow;\n  if (flexShrink === undefined) flexShrink = defaultFlexShrink;\n  if (flexBasis === undefined) flexBasis = defaultFlexBasis;\n  return {\n    flexGrow: flexGrow,\n    flexShrink: flexShrink,\n    flexBasis: flexBasis\n  };\n};\n\nvar FLEX_WRAP = regExpToken(/(nowrap|wrap|wrap-reverse)/);\nvar FLEX_DIRECTION = regExpToken(/(row|row-reverse|column|column-reverse)/);\nvar defaultFlexWrap = 'nowrap';\nvar defaultFlexDirection = 'row';\n\nvar flexFlow = function flexFlow(tokenStream) {\n  var flexWrap;\n  var flexDirection;\n  var partsParsed = 0;\n\n  while (partsParsed < 2 && tokenStream.hasTokens()) {\n    if (partsParsed !== 0) tokenStream.expect(SPACE);\n\n    if (flexWrap === undefined && tokenStream.matches(FLEX_WRAP)) {\n      flexWrap = tokenStream.lastValue;\n    } else if (flexDirection === undefined && tokenStream.matches(FLEX_DIRECTION)) {\n      flexDirection = tokenStream.lastValue;\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    partsParsed += 1;\n  }\n\n  tokenStream.expectEmpty();\n  if (flexWrap === undefined) flexWrap = defaultFlexWrap;\n  if (flexDirection === undefined) flexDirection = defaultFlexDirection;\n  return {\n    flexWrap: flexWrap,\n    flexDirection: flexDirection\n  };\n};\n\nvar fontFamily = function fontFamily(tokenStream) {\n  var fontFamily;\n\n  if (tokenStream.matches(STRING)) {\n    fontFamily = tokenStream.lastValue;\n  } else {\n    fontFamily = tokenStream.expect(IDENT);\n\n    while (tokenStream.hasTokens()) {\n      tokenStream.expect(SPACE);\n      var nextIdent = tokenStream.expect(IDENT);\n      fontFamily += \" \" + nextIdent;\n    }\n  }\n\n  tokenStream.expectEmpty();\n  return {\n    fontFamily: fontFamily\n  };\n};\n\nvar NORMAL = regExpToken(/^(normal)$/);\nvar STYLE = regExpToken(/^(italic)$/);\nvar WEIGHT = regExpToken(/^([1-9]00|bold)$/);\nvar VARIANT = regExpToken(/^(small-caps)$/);\nvar defaultFontStyle = 'normal';\nvar defaultFontWeight = 'normal';\nvar defaultFontVariant = [];\n\nvar font = function font(tokenStream) {\n  var fontStyle;\n  var fontWeight;\n  var fontVariant; // let fontSize;\n\n  var lineHeight; // let fontFamily;\n\n  var numStyleWeightVariantMatched = 0;\n\n  while (numStyleWeightVariantMatched < 3 && tokenStream.hasTokens()) {\n    if (tokenStream.matches(NORMAL)) ;else if (fontStyle === undefined && tokenStream.matches(STYLE)) {\n      fontStyle = tokenStream.lastValue;\n    } else if (fontWeight === undefined && tokenStream.matches(WEIGHT)) {\n      fontWeight = tokenStream.lastValue;\n    } else if (fontVariant === undefined && tokenStream.matches(VARIANT)) {\n      fontVariant = [tokenStream.lastValue];\n    } else {\n      break;\n    }\n    tokenStream.expect(SPACE);\n    numStyleWeightVariantMatched += 1;\n  }\n\n  var fontSize = tokenStream.expect(LENGTH, UNSUPPORTED_LENGTH_UNIT);\n\n  if (tokenStream.matches(SLASH)) {\n    lineHeight = tokenStream.expect(LENGTH, UNSUPPORTED_LENGTH_UNIT);\n  }\n\n  tokenStream.expect(SPACE);\n\n  var _fontFamily = fontFamily(tokenStream),\n      fontFamily$1 = _fontFamily.fontFamily;\n\n  if (fontStyle === undefined) fontStyle = defaultFontStyle;\n  if (fontWeight === undefined) fontWeight = defaultFontWeight;\n  if (fontVariant === undefined) fontVariant = defaultFontVariant;\n  var out = {\n    fontStyle: fontStyle,\n    fontWeight: fontWeight,\n    fontVariant: fontVariant,\n    fontSize: fontSize,\n    fontFamily: fontFamily$1\n  };\n  if (lineHeight !== undefined) out.lineHeight = lineHeight;\n  return out;\n};\n\nvar ALIGN_CONTENT = regExpToken(/(flex-(?:start|end)|center|stretch|space-(?:between|around))/);\nvar JUSTIFY_CONTENT = regExpToken(/(flex-(?:start|end)|center|space-(?:between|around|evenly))/);\n\nvar placeContent = function placeContent(tokenStream) {\n  var alignContent = tokenStream.expect(ALIGN_CONTENT);\n  var justifyContent;\n\n  if (tokenStream.hasTokens()) {\n    tokenStream.expect(SPACE);\n    justifyContent = tokenStream.expect(JUSTIFY_CONTENT);\n  } else {\n    justifyContent = 'stretch';\n  }\n\n  tokenStream.expectEmpty();\n  return {\n    alignContent: alignContent,\n    justifyContent: justifyContent\n  };\n};\n\nvar STYLE$1 = regExpToken(/^(solid|double|dotted|dashed)$/);\nvar defaultTextDecorationLine = 'none';\nvar defaultTextDecorationStyle = 'solid';\nvar defaultTextDecorationColor = 'black';\n\nvar textDecoration = function textDecoration(tokenStream) {\n  var line;\n  var style;\n  var color;\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE);\n\n    if (line === undefined && tokenStream.matches(LINE)) {\n      var lines = [tokenStream.lastValue.toLowerCase()];\n      tokenStream.saveRewindPoint();\n\n      if (lines[0] !== 'none' && tokenStream.matches(SPACE) && tokenStream.matches(LINE)) {\n        lines.push(tokenStream.lastValue.toLowerCase()); // Underline comes before line-through\n\n        lines.sort().reverse();\n      } else {\n        tokenStream.rewind();\n      }\n\n      line = lines.join(' ');\n    } else if (style === undefined && tokenStream.matches(STYLE$1)) {\n      style = tokenStream.lastValue;\n    } else if (color === undefined && tokenStream.matches(COLOR)) {\n      color = tokenStream.lastValue;\n    } else {\n      tokenStream[\"throw\"]();\n    }\n\n    didParseFirst = true;\n  }\n\n  return {\n    textDecorationLine: line !== undefined ? line : defaultTextDecorationLine,\n    textDecorationColor: color !== undefined ? color : defaultTextDecorationColor,\n    textDecorationStyle: style !== undefined ? style : defaultTextDecorationStyle\n  };\n};\n\nvar textDecorationLine = function textDecorationLine(tokenStream) {\n  var lines = [];\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE);\n    lines.push(tokenStream.expect(LINE).toLowerCase());\n    didParseFirst = true;\n  }\n\n  lines.sort().reverse();\n  return {\n    textDecorationLine: lines.join(' ')\n  };\n};\n\nvar textShadow = function textShadow(tokenStream) {\n  var _parseShadow2 = parseShadow(tokenStream),\n      offset = _parseShadow2.offset,\n      radius = _parseShadow2.radius,\n      color = _parseShadow2.color;\n\n  return {\n    textShadowOffset: offset,\n    textShadowRadius: radius,\n    textShadowColor: color\n  };\n};\n\nvar oneOfType = function oneOfType(tokenType) {\n  return function (functionStream) {\n    var value = functionStream.expect(tokenType);\n    functionStream.expectEmpty();\n    return value;\n  };\n};\n\nvar singleNumber = oneOfType(NUMBER);\nvar singleLength = oneOfType(LENGTH);\nvar singleAngle = oneOfType(ANGLE);\n\nvar xyTransformFactory = function xyTransformFactory(tokenType) {\n  return function (key, valueIfOmitted) {\n    return function (functionStream) {\n      var _ref3, _ref4;\n\n      var x = functionStream.expect(tokenType);\n      var y;\n\n      if (functionStream.hasTokens()) {\n        functionStream.expect(COMMA);\n        y = functionStream.expect(tokenType);\n      } else if (valueIfOmitted !== undefined) {\n        y = valueIfOmitted;\n      } else {\n        // Assumption, if x === y, then we can omit XY\n        // I.e. scale(5) => [{ scale: 5 }] rather than [{ scaleX: 5 }, { scaleY: 5 }]\n        return x;\n      }\n\n      functionStream.expectEmpty();\n      return [(_ref3 = {}, _ref3[key + \"Y\"] = y, _ref3), (_ref4 = {}, _ref4[key + \"X\"] = x, _ref4)];\n    };\n  };\n};\n\nvar xyNumber = xyTransformFactory(NUMBER);\nvar xyLength = xyTransformFactory(LENGTH);\nvar xyAngle = xyTransformFactory(ANGLE);\nvar partTransforms = {\n  perspective: singleNumber,\n  scale: xyNumber('scale'),\n  scaleX: singleNumber,\n  scaleY: singleNumber,\n  translate: xyLength('translate', 0),\n  translateX: singleLength,\n  translateY: singleLength,\n  rotate: singleAngle,\n  rotateX: singleAngle,\n  rotateY: singleAngle,\n  rotateZ: singleAngle,\n  skewX: singleAngle,\n  skewY: singleAngle,\n  skew: xyAngle('skew', '0deg')\n};\n\nvar transform = function transform(tokenStream) {\n  var transforms = [];\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE);\n    var functionStream = tokenStream.expectFunction();\n    var functionName = functionStream.functionName;\n    var transformedValues = partTransforms[functionName](functionStream);\n\n    if (!Array.isArray(transformedValues)) {\n      var _ref5;\n\n      transformedValues = [(_ref5 = {}, _ref5[functionName] = transformedValues, _ref5)];\n    }\n\n    transforms = transformedValues.concat(transforms);\n    didParseFirst = true;\n  }\n\n  return {\n    transform: transforms\n  };\n};\n\nvar background = function background(tokenStream) {\n  return {\n    backgroundColor: tokenStream.expect(COLOR)\n  };\n};\n\nvar borderColor = directionFactory({\n  types: [COLOR],\n  prefix: 'border',\n  suffix: 'Color'\n});\nvar borderRadius = directionFactory({\n  directions: ['TopLeft', 'TopRight', 'BottomRight', 'BottomLeft'],\n  prefix: 'border',\n  suffix: 'Radius'\n});\nvar borderWidth = directionFactory({\n  prefix: 'border',\n  suffix: 'Width'\n});\nvar margin = directionFactory({\n  types: [LENGTH, UNSUPPORTED_LENGTH_UNIT, PERCENT, AUTO],\n  prefix: 'margin'\n});\nvar padding = directionFactory({\n  prefix: 'padding'\n});\n\nvar fontVariant = function fontVariant(tokenStream) {\n  return {\n    fontVariant: [tokenStream.expect(IDENT)]\n  };\n};\n\nvar fontWeight = function fontWeight(tokenStream) {\n  return {\n    fontWeight: tokenStream.expect(WORD) // Also match numbers as strings\n\n  };\n};\n\nvar shadowOffset = function shadowOffset(tokenStream) {\n  return {\n    shadowOffset: parseShadowOffset(tokenStream)\n  };\n};\n\nvar textShadowOffset = function textShadowOffset(tokenStream) {\n  return {\n    textShadowOffset: parseShadowOffset(tokenStream)\n  };\n};\n\nvar transforms = {\n  background: background,\n  border: border,\n  borderColor: borderColor,\n  borderRadius: borderRadius,\n  borderWidth: borderWidth,\n  boxShadow: boxShadow,\n  flex: flex,\n  flexFlow: flexFlow,\n  font: font,\n  fontFamily: fontFamily,\n  fontVariant: fontVariant,\n  fontWeight: fontWeight,\n  margin: margin,\n  padding: padding,\n  placeContent: placeContent,\n  shadowOffset: shadowOffset,\n  textShadow: textShadow,\n  textShadowOffset: textShadowOffset,\n  textDecoration: textDecoration,\n  textDecorationLine: textDecorationLine,\n  transform: transform\n};\nvar propertiesWithoutUnits;\n\nif (process.env.NODE_ENV !== 'production') {\n  propertiesWithoutUnits = ['aspectRatio', 'elevation', 'flexGrow', 'flexShrink', 'opacity', 'shadowOpacity', 'zIndex'];\n}\n\nvar devPropertiesWithUnitsRegExp = propertiesWithoutUnits != null ? new RegExp(propertiesWithoutUnits.join('|')) : null;\nvar SYMBOL_MATCH = 'SYMBOL_MATCH';\n\nvar TokenStream =\n/*#__PURE__*/\nfunction () {\n  function TokenStream(nodes, parent) {\n    this.index = 0;\n    this.nodes = nodes;\n    this.functionName = parent != null ? parent.value : null;\n    this.lastValue = null;\n    this.rewindIndex = -1;\n  }\n\n  var _proto = TokenStream.prototype;\n\n  _proto.hasTokens = function hasTokens() {\n    return this.index <= this.nodes.length - 1;\n  };\n\n  _proto[SYMBOL_MATCH] = function () {\n    if (!this.hasTokens()) return null;\n    var node = this.nodes[this.index];\n\n    for (var i = 0; i < arguments.length; i += 1) {\n      var tokenDescriptor = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      var value = tokenDescriptor(node);\n\n      if (value !== null) {\n        this.index += 1;\n        this.lastValue = value;\n        return value;\n      }\n    }\n\n    return null;\n  };\n\n  _proto.matches = function matches() {\n    return this[SYMBOL_MATCH].apply(this, arguments) !== null;\n  };\n\n  _proto.expect = function expect() {\n    var value = this[SYMBOL_MATCH].apply(this, arguments);\n    return value !== null ? value : this[\"throw\"]();\n  };\n\n  _proto.matchesFunction = function matchesFunction() {\n    var node = this.nodes[this.index];\n    if (node.type !== 'function') return null;\n    var value = new TokenStream(node.nodes, node);\n    this.index += 1;\n    this.lastValue = null;\n    return value;\n  };\n\n  _proto.expectFunction = function expectFunction() {\n    var value = this.matchesFunction();\n    return value !== null ? value : this[\"throw\"]();\n  };\n\n  _proto.expectEmpty = function expectEmpty() {\n    if (this.hasTokens()) this[\"throw\"]();\n  };\n\n  _proto[\"throw\"] = function _throw() {\n    throw new Error(\"Unexpected token type: \" + this.nodes[this.index].type);\n  };\n\n  _proto.saveRewindPoint = function saveRewindPoint() {\n    this.rewindIndex = this.index;\n  };\n\n  _proto.rewind = function rewind() {\n    if (this.rewindIndex === -1) throw new Error('Internal error');\n    this.index = this.rewindIndex;\n    this.lastValue = null;\n  };\n\n  return TokenStream;\n}();\n/* eslint-disable no-param-reassign */\n// Note if this is wrong, you'll need to change tokenTypes.js too\n\n\nvar numberOrLengthRe = /^([+-]?(?:\\d*\\.)?\\d+(?:e[+-]?\\d+)?)(?:px)?$/i;\nvar numberOnlyRe = /^[+-]?(?:\\d*\\.\\d*|[1-9]\\d*)(?:e[+-]?\\d+)?$/i;\nvar boolRe = /^true|false$/i;\nvar nullRe = /^null$/i;\nvar undefinedRe = /^undefined$/i; // Undocumented export\n\nvar transformRawValue = function transformRawValue(propName, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    var needsUnit = !devPropertiesWithUnitsRegExp.test(propName);\n    var isNumberWithoutUnit = numberOnlyRe.test(value);\n\n    if (needsUnit && isNumberWithoutUnit) {\n      // eslint-disable-next-line no-console\n      console.warn(\"Expected style \\\"\" + propName + \": \" + value + \"\\\" to contain units\");\n    }\n\n    if (!needsUnit && value !== '0' && !isNumberWithoutUnit) {\n      // eslint-disable-next-line no-console\n      console.warn(\"Expected style \\\"\" + propName + \": \" + value + \"\\\" to be unitless\");\n    }\n  }\n\n  var numberMatch = value.match(numberOrLengthRe);\n  if (numberMatch !== null) return Number(numberMatch[1]);\n  var boolMatch = value.match(boolRe);\n  if (boolMatch !== null) return boolMatch[0].toLowerCase() === 'true';\n  var nullMatch = value.match(nullRe);\n  if (nullMatch !== null) return null;\n  var undefinedMatch = value.match(undefinedRe);\n  if (undefinedMatch !== null) return undefined;\n  return value;\n};\n\nvar baseTransformShorthandValue = function baseTransformShorthandValue(propName, value) {\n  var ast = parse__default(value);\n  var tokenStream = new TokenStream(ast.nodes);\n  return transforms[propName](tokenStream);\n};\n\nvar transformShorthandValue = process.env.NODE_ENV === 'production' ? baseTransformShorthandValue : function (propName, value) {\n  try {\n    return baseTransformShorthandValue(propName, value);\n  } catch (e) {\n    throw new Error(\"Failed to parse declaration \\\"\" + propName + \": \" + value + \"\\\"\");\n  }\n};\n\nvar getStylesForProperty = function getStylesForProperty(propName, inputValue, allowShorthand) {\n  var _ref6;\n\n  var isRawValue = allowShorthand === false || !(propName in transforms);\n  var value = inputValue.trim();\n  var propValues = isRawValue ? (_ref6 = {}, _ref6[propName] = transformRawValue(propName, value), _ref6) : transformShorthandValue(propName, value);\n  return propValues;\n};\n\nvar getPropertyName = function getPropertyName(propName) {\n  var isCustomProp = /^--\\w+/.test(propName);\n\n  if (isCustomProp) {\n    return propName;\n  }\n\n  return camelizeStyleName(propName);\n};\n\nvar index = function index(rules, shorthandBlacklist) {\n  if (shorthandBlacklist === void 0) {\n    shorthandBlacklist = [];\n  }\n\n  return rules.reduce(function (accum, rule) {\n    var propertyName = getPropertyName(rule[0]);\n    var value = rule[1];\n    var allowShorthand = shorthandBlacklist.indexOf(propertyName) === -1;\n    return Object.assign(accum, getStylesForProperty(propertyName, value, allowShorthand));\n  }, {});\n};\n\nexports[\"default\"] = index;\nexports.getPropertyName = getPropertyName;\nexports.getStylesForProperty = getStylesForProperty;\nexports.transformRawValue = transformRawValue;\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"var openParentheses = \"(\".charCodeAt(0);\nvar closeParentheses = \")\".charCodeAt(0);\nvar singleQuote = \"'\".charCodeAt(0);\nvar doubleQuote = '\"'.charCodeAt(0);\nvar backslash = \"\\\\\".charCodeAt(0);\nvar slash = \"/\".charCodeAt(0);\nvar comma = \",\".charCodeAt(0);\nvar colon = \":\".charCodeAt(0);\nvar star = \"*\".charCodeAt(0);\nvar uLower = \"u\".charCodeAt(0);\nvar uUpper = \"U\".charCodeAt(0);\nvar plus = \"+\".charCodeAt(0);\nvar isUnicodeRange = /^[a-f0-9?-]+$/i;\n\nmodule.exports = function (input) {\n  var tokens = [];\n  var value = input;\n  var next, quote, prev, token, escape, escapePos, whitespacePos, parenthesesOpenPos;\n  var pos = 0;\n  var code = value.charCodeAt(pos);\n  var max = value.length;\n  var stack = [{\n    nodes: tokens\n  }];\n  var balanced = 0;\n  var parent;\n  var name = \"\";\n  var before = \"\";\n  var after = \"\";\n\n  while (pos < max) {\n    // Whitespaces\n    if (code <= 32) {\n      next = pos;\n\n      do {\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (code <= 32);\n\n      token = value.slice(pos, next);\n      prev = tokens[tokens.length - 1];\n\n      if (code === closeParentheses && balanced) {\n        after = token;\n      } else if (prev && prev.type === \"div\") {\n        prev.after = token;\n        prev.sourceEndIndex += token.length;\n      } else if (code === comma || code === colon || code === slash && value.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === \"function\" && parent.value !== \"calc\")) {\n        before = token;\n      } else {\n        tokens.push({\n          type: \"space\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      }\n\n      pos = next; // Quotes\n    } else if (code === singleQuote || code === doubleQuote) {\n      next = pos;\n      quote = code === singleQuote ? \"'\" : '\"';\n      token = {\n        type: \"string\",\n        sourceIndex: pos,\n        quote: quote\n      };\n\n      do {\n        escape = false;\n        next = value.indexOf(quote, next + 1);\n\n        if (~next) {\n          escapePos = next;\n\n          while (value.charCodeAt(escapePos - 1) === backslash) {\n            escapePos -= 1;\n            escape = !escape;\n          }\n        } else {\n          value += quote;\n          next = value.length - 1;\n          token.unclosed = true;\n        }\n      } while (escape);\n\n      token.value = value.slice(pos + 1, next);\n      token.sourceEndIndex = token.unclosed ? next : next + 1;\n      tokens.push(token);\n      pos = next + 1;\n      code = value.charCodeAt(pos); // Comments\n    } else if (code === slash && value.charCodeAt(pos + 1) === star) {\n      next = value.indexOf(\"*/\", pos);\n      token = {\n        type: \"comment\",\n        sourceIndex: pos,\n        sourceEndIndex: next + 2\n      };\n\n      if (next === -1) {\n        token.unclosed = true;\n        next = value.length;\n        token.sourceEndIndex = next;\n      }\n\n      token.value = value.slice(pos + 2, next);\n      tokens.push(token);\n      pos = next + 2;\n      code = value.charCodeAt(pos); // Operation within calc\n    } else if ((code === slash || code === star) && parent && parent.type === \"function\" && parent.value === \"calc\") {\n      token = value[pos];\n      tokens.push({\n        type: \"word\",\n        sourceIndex: pos - before.length,\n        sourceEndIndex: pos + token.length,\n        value: token\n      });\n      pos += 1;\n      code = value.charCodeAt(pos); // Dividers\n    } else if (code === slash || code === comma || code === colon) {\n      token = value[pos];\n      tokens.push({\n        type: \"div\",\n        sourceIndex: pos - before.length,\n        sourceEndIndex: pos + token.length,\n        value: token,\n        before: before,\n        after: \"\"\n      });\n      before = \"\";\n      pos += 1;\n      code = value.charCodeAt(pos); // Open parentheses\n    } else if (openParentheses === code) {\n      // Whitespaces after open parentheses\n      next = pos;\n\n      do {\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (code <= 32);\n\n      parenthesesOpenPos = pos;\n      token = {\n        type: \"function\",\n        sourceIndex: pos - name.length,\n        value: name,\n        before: value.slice(parenthesesOpenPos + 1, next)\n      };\n      pos = next;\n\n      if (name === \"url\" && code !== singleQuote && code !== doubleQuote) {\n        next -= 1;\n\n        do {\n          escape = false;\n          next = value.indexOf(\")\", next + 1);\n\n          if (~next) {\n            escapePos = next;\n\n            while (value.charCodeAt(escapePos - 1) === backslash) {\n              escapePos -= 1;\n              escape = !escape;\n            }\n          } else {\n            value += \")\";\n            next = value.length - 1;\n            token.unclosed = true;\n          }\n        } while (escape); // Whitespaces before closed\n\n\n        whitespacePos = next;\n\n        do {\n          whitespacePos -= 1;\n          code = value.charCodeAt(whitespacePos);\n        } while (code <= 32);\n\n        if (parenthesesOpenPos < whitespacePos) {\n          if (pos !== whitespacePos + 1) {\n            token.nodes = [{\n              type: \"word\",\n              sourceIndex: pos,\n              sourceEndIndex: whitespacePos + 1,\n              value: value.slice(pos, whitespacePos + 1)\n            }];\n          } else {\n            token.nodes = [];\n          }\n\n          if (token.unclosed && whitespacePos + 1 !== next) {\n            token.after = \"\";\n            token.nodes.push({\n              type: \"space\",\n              sourceIndex: whitespacePos + 1,\n              sourceEndIndex: next,\n              value: value.slice(whitespacePos + 1, next)\n            });\n          } else {\n            token.after = value.slice(whitespacePos + 1, next);\n            token.sourceEndIndex = next;\n          }\n        } else {\n          token.after = \"\";\n          token.nodes = [];\n        }\n\n        pos = next + 1;\n        token.sourceEndIndex = token.unclosed ? next : pos;\n        code = value.charCodeAt(pos);\n        tokens.push(token);\n      } else {\n        balanced += 1;\n        token.after = \"\";\n        token.sourceEndIndex = pos + 1;\n        tokens.push(token);\n        stack.push(token);\n        tokens = token.nodes = [];\n        parent = token;\n      }\n\n      name = \"\"; // Close parentheses\n    } else if (closeParentheses === code && balanced) {\n      pos += 1;\n      code = value.charCodeAt(pos);\n      parent.after = after;\n      parent.sourceEndIndex += after.length;\n      after = \"\";\n      balanced -= 1;\n      stack[stack.length - 1].sourceEndIndex = pos;\n      stack.pop();\n      parent = stack[balanced];\n      tokens = parent.nodes; // Words\n    } else {\n      next = pos;\n\n      do {\n        if (code === backslash) {\n          next += 1;\n        }\n\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (next < max && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === \"function\" && parent.value === \"calc\" || code === slash && parent.type === \"function\" && parent.value === \"calc\" || code === closeParentheses && balanced));\n\n      token = value.slice(pos, next);\n\n      if (openParentheses === code) {\n        name = token;\n      } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {\n        tokens.push({\n          type: \"unicode-range\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      } else {\n        tokens.push({\n          type: \"word\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      }\n\n      pos = next;\n    }\n  }\n\n  for (pos = stack.length - 1; pos; pos -= 1) {\n    stack[pos].unclosed = true;\n    stack[pos].sourceEndIndex = value.length;\n  }\n\n  return stack[0].nodes;\n};","map":{"version":3,"sources":["G:/Dropbox (Personale)/Programming/ecommerce-site/node_modules/postcss-value-parser/lib/parse.js"],"names":["openParentheses","charCodeAt","closeParentheses","singleQuote","doubleQuote","backslash","slash","comma","colon","star","uLower","uUpper","plus","isUnicodeRange","module","exports","input","tokens","value","next","quote","prev","token","escape","escapePos","whitespacePos","parenthesesOpenPos","pos","code","max","length","stack","nodes","balanced","parent","name","before","after","slice","type","sourceEndIndex","push","sourceIndex","indexOf","unclosed","pop","test"],"mappings":"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","sourcesContent":["var openParentheses = \"(\".charCodeAt(0);\nvar closeParentheses = \")\".charCodeAt(0);\nvar singleQuote = \"'\".charCodeAt(0);\nvar doubleQuote = '\"'.charCodeAt(0);\nvar backslash = \"\\\\\".charCodeAt(0);\nvar slash = \"/\".charCodeAt(0);\nvar comma = \",\".charCodeAt(0);\nvar colon = \":\".charCodeAt(0);\nvar star = \"*\".charCodeAt(0);\nvar uLower = \"u\".charCodeAt(0);\nvar uUpper = \"U\".charCodeAt(0);\nvar plus = \"+\".charCodeAt(0);\nvar isUnicodeRange = /^[a-f0-9?-]+$/i;\n\nmodule.exports = function(input) {\n  var tokens = [];\n  var value = input;\n\n  var next,\n    quote,\n    prev,\n    token,\n    escape,\n    escapePos,\n    whitespacePos,\n    parenthesesOpenPos;\n  var pos = 0;\n  var code = value.charCodeAt(pos);\n  var max = value.length;\n  var stack = [{ nodes: tokens }];\n  var balanced = 0;\n  var parent;\n\n  var name = \"\";\n  var before = \"\";\n  var after = \"\";\n\n  while (pos < max) {\n    // Whitespaces\n    if (code <= 32) {\n      next = pos;\n      do {\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (code <= 32);\n      token = value.slice(pos, next);\n\n      prev = tokens[tokens.length - 1];\n      if (code === closeParentheses && balanced) {\n        after = token;\n      } else if (prev && prev.type === \"div\") {\n        prev.after = token;\n        prev.sourceEndIndex += token.length;\n      } else if (\n        code === comma ||\n        code === colon ||\n        (code === slash &&\n          value.charCodeAt(next + 1) !== star &&\n          (!parent ||\n            (parent && parent.type === \"function\" && parent.value !== \"calc\")))\n      ) {\n        before = token;\n      } else {\n        tokens.push({\n          type: \"space\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      }\n\n      pos = next;\n\n      // Quotes\n    } else if (code === singleQuote || code === doubleQuote) {\n      next = pos;\n      quote = code === singleQuote ? \"'\" : '\"';\n      token = {\n        type: \"string\",\n        sourceIndex: pos,\n        quote: quote\n      };\n      do {\n        escape = false;\n        next = value.indexOf(quote, next + 1);\n        if (~next) {\n          escapePos = next;\n          while (value.charCodeAt(escapePos - 1) === backslash) {\n            escapePos -= 1;\n            escape = !escape;\n          }\n        } else {\n          value += quote;\n          next = value.length - 1;\n          token.unclosed = true;\n        }\n      } while (escape);\n      token.value = value.slice(pos + 1, next);\n      token.sourceEndIndex = token.unclosed ? next : next + 1;\n      tokens.push(token);\n      pos = next + 1;\n      code = value.charCodeAt(pos);\n\n      // Comments\n    } else if (code === slash && value.charCodeAt(pos + 1) === star) {\n      next = value.indexOf(\"*/\", pos);\n\n      token = {\n        type: \"comment\",\n        sourceIndex: pos,\n        sourceEndIndex: next + 2\n      };\n\n      if (next === -1) {\n        token.unclosed = true;\n        next = value.length;\n        token.sourceEndIndex = next;\n      }\n\n      token.value = value.slice(pos + 2, next);\n      tokens.push(token);\n\n      pos = next + 2;\n      code = value.charCodeAt(pos);\n\n      // Operation within calc\n    } else if (\n      (code === slash || code === star) &&\n      parent &&\n      parent.type === \"function\" &&\n      parent.value === \"calc\"\n    ) {\n      token = value[pos];\n      tokens.push({\n        type: \"word\",\n        sourceIndex: pos - before.length,\n        sourceEndIndex: pos + token.length,\n        value: token\n      });\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      // Dividers\n    } else if (code === slash || code === comma || code === colon) {\n      token = value[pos];\n\n      tokens.push({\n        type: \"div\",\n        sourceIndex: pos - before.length,\n        sourceEndIndex: pos + token.length,\n        value: token,\n        before: before,\n        after: \"\"\n      });\n      before = \"\";\n\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      // Open parentheses\n    } else if (openParentheses === code) {\n      // Whitespaces after open parentheses\n      next = pos;\n      do {\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (code <= 32);\n      parenthesesOpenPos = pos;\n      token = {\n        type: \"function\",\n        sourceIndex: pos - name.length,\n        value: name,\n        before: value.slice(parenthesesOpenPos + 1, next)\n      };\n      pos = next;\n\n      if (name === \"url\" && code !== singleQuote && code !== doubleQuote) {\n        next -= 1;\n        do {\n          escape = false;\n          next = value.indexOf(\")\", next + 1);\n          if (~next) {\n            escapePos = next;\n            while (value.charCodeAt(escapePos - 1) === backslash) {\n              escapePos -= 1;\n              escape = !escape;\n            }\n          } else {\n            value += \")\";\n            next = value.length - 1;\n            token.unclosed = true;\n          }\n        } while (escape);\n        // Whitespaces before closed\n        whitespacePos = next;\n        do {\n          whitespacePos -= 1;\n          code = value.charCodeAt(whitespacePos);\n        } while (code <= 32);\n        if (parenthesesOpenPos < whitespacePos) {\n          if (pos !== whitespacePos + 1) {\n            token.nodes = [\n              {\n                type: \"word\",\n                sourceIndex: pos,\n                sourceEndIndex: whitespacePos + 1,\n                value: value.slice(pos, whitespacePos + 1)\n              }\n            ];\n          } else {\n            token.nodes = [];\n          }\n          if (token.unclosed && whitespacePos + 1 !== next) {\n            token.after = \"\";\n            token.nodes.push({\n              type: \"space\",\n              sourceIndex: whitespacePos + 1,\n              sourceEndIndex: next,\n              value: value.slice(whitespacePos + 1, next)\n            });\n          } else {\n            token.after = value.slice(whitespacePos + 1, next);\n            token.sourceEndIndex = next;\n          }\n        } else {\n          token.after = \"\";\n          token.nodes = [];\n        }\n        pos = next + 1;\n        token.sourceEndIndex = token.unclosed ? next : pos;\n        code = value.charCodeAt(pos);\n        tokens.push(token);\n      } else {\n        balanced += 1;\n        token.after = \"\";\n        token.sourceEndIndex = pos + 1;\n        tokens.push(token);\n        stack.push(token);\n        tokens = token.nodes = [];\n        parent = token;\n      }\n      name = \"\";\n\n      // Close parentheses\n    } else if (closeParentheses === code && balanced) {\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      parent.after = after;\n      parent.sourceEndIndex += after.length;\n      after = \"\";\n      balanced -= 1;\n      stack[stack.length - 1].sourceEndIndex = pos;\n      stack.pop();\n      parent = stack[balanced];\n      tokens = parent.nodes;\n\n      // Words\n    } else {\n      next = pos;\n      do {\n        if (code === backslash) {\n          next += 1;\n        }\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (\n        next < max &&\n        !(\n          code <= 32 ||\n          code === singleQuote ||\n          code === doubleQuote ||\n          code === comma ||\n          code === colon ||\n          code === slash ||\n          code === openParentheses ||\n          (code === star &&\n            parent &&\n            parent.type === \"function\" &&\n            parent.value === \"calc\") ||\n          (code === slash &&\n            parent.type === \"function\" &&\n            parent.value === \"calc\") ||\n          (code === closeParentheses && balanced)\n        )\n      );\n      token = value.slice(pos, next);\n\n      if (openParentheses === code) {\n        name = token;\n      } else if (\n        (uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) &&\n        plus === token.charCodeAt(1) &&\n        isUnicodeRange.test(token.slice(2))\n      ) {\n        tokens.push({\n          type: \"unicode-range\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      } else {\n        tokens.push({\n          type: \"word\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      }\n\n      pos = next;\n    }\n  }\n\n  for (pos = stack.length - 1; pos; pos -= 1) {\n    stack[pos].unclosed = true;\n    stack[pos].sourceEndIndex = value.length;\n  }\n\n  return stack[0].nodes;\n};\n"]},"metadata":{},"sourceType":"script"}